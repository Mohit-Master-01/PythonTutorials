# -*- coding: utf-8 -*-
"""PythonCourse.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Q-oYfpMso3fPiHX6Z9t_qIHJsjWs4o01
"""

# print function
print("Hello world")

#Variables
a = 5
a_5 = 6
print(a_5)

#In Python, the help() function is a built-in function that provides information about modules, classes, functions, and modules
help("keywords")

#The id() function returns a unique id for the specified object.
id(a)

#DataTypes
number = 24
f = 1.0
b = True
s = "Mohit 123 @"
m = """
this is a multi line string
"""
n = None
print(number,",",f,",",b,",",s,",",m,",",n)

#The type() function returns a type object that represents the type of the passed argument.
print(type(number),",", type(f),",",type(b),",",type(s),",",type(m),",",type(n))

#The input() function allows user input.
name = input()

type(name)

#Type conversion
x = input()

y = float(x)
print(y,"," ,type(y))

c = float("1.5")
type(c)

int(c)

#printing multiple values using print function
print("Mohit")

#The sep parameter of the print() function is used to specify the separator between the strings
print("Mohit","Priya","17","04","2004","2005",sep=" , ")
print("Mohit","20",sep="\n")

#The end parameter in the print function is used to add any string
print("Mohit","20",end=" ", sep="->")
print("Priya","20",sep="->")

#Special operators
#in operator tells you if an object is part of other object or not

name = "Rahul Janghu"
print("R" in name)
print("r" in name)

#is operator tells you if both the object are at same memory location
a = 5
b = 5

print(id(a), id(b))

a is b

#if else syntax
age = int(input())

if age > 18:
  print("You are eligible")
  print("drive slow")
else:
  print("Age should not be less than 18")

#Nested if else

age = int(input())

if age > 18:
  if age >= 65:
    print("Take rest")
  else:
    print("You are eligible")
    print("drive slow")
else:
  print("Age should not be less than 18")

#if, elif and else
num = int(input())

if num > 0:
  print("Positive")
if num == 0:
  print("Zero")
else:
  print("Negative")

num = int(input())

if num > 0:
  print("Positive")
elif num == 0:
  print("Zero")
else:
  print("Negative")

#Find maximum

marks = [90,30,100,50,80,95]

highest = marks[0]
for i in marks:
  if i > highest:
    highest = i

print(highest)
max(marks)
min(marks)

#while loop
i = 1
#loop condition
while i <= 6:
  #inside body
  print("You are the best")

  #update
  i += 1

#Print all numbers from 1 to 10

i = 1

while i <= 10:
  print(i,end=" ")
  i += 1

#Print all even numbers from 0 to 10

i = 0

while i <= 10:
  if i % 2 == 0:
    print(i, end=" ")

  i += 1

#Print sum of all numbers from 0 to 10
i = 1

while i <= 10:
  print(i,end=" ")

  i += 1

#Print sum of all numbers from 1 to 10

i = 1
add = 0

while i <= 10:
  add += i
  print(add,end=" ")

  i+=1
print(add)

#Range function - allow users to generate series of numbers
#It is iterable as well
#Here start is 0 and jump is 1
print(range(5))
list(range(5))

#By default jimp here will be 1
list(range(1,5))

#Start is included and end is excluded
list(range(2,5))

print(list(range(1,10,2)))
print(list(range(10,1,1)))
print(list(range(10,1,-1)))
print(list(range(10,0,-2)))
print(list(range(-1,10)))

#For loop
#i : iterator, range() : iterable
for i in range(1,11):
  print(i, end=",")

#Print multiplication table of 5

n = int(input())

for i in range(1,11):
  print(n,"*",i,"=",i*n)

#Print pattern 1

for i in range(4):
  for j in  range(4):
    print("#",end=" ")
  print()#brings into new line

#Print pattern 2

n = int(input())

for i in range(1,n+1):
  for j in range(i):
    print("#",end=" ")
  print()

#Break, Continue and Pass
#use to alter the flow of a program
#break : breaks the flow of program once this condition is hit
#continue : skips that particular iteration
#pass : to avoid syntax error

for i in range(1,10):
  pass

#continue

for i in range(1,10):
  if i == 5:
    continue
  print(i,end=" ")

#break

for i in range(1,10):
  if i == 5:
    break
  print(i,end=" ")

i = 1

while i < 10:
  if i == 5:
    break
  print(i,end=" ")
  i += 1

#Strings
#sequence of characters(alphabets, digits, whitespaces, special characters)
#can be defined using single, double or triple quotes

"Rahul" == "luhaR"

#Indexing in a String

name = "Rahul Janghu"

name[2]

name[-1]

len(name)

size = len(name)

print(name[-size])
print(size)

#String Slicing

name = "Rahul Janghu"
print(name[0])
print(name[0:3])
print(name[0:])

size = len(name)
print(name[2:size])
print(name[:])
print(name[::2])
print(name[:-1])
print(name[-2])
print(name[1:-2:-1])
print(name[-1:0])
print(name[::-1])
print(name[-1 : -(len(name) % 1) : -1])

#String methods
name.capitalize()

name.upper()

name.lower()

name.find("a")

name.count("Ra")

name.title()

name.split()

name.index("R")

name.replace("J","j")

name.isupper()

name.islower()

name.isnumeric()

name = "Rahul"
print(name.isalpha())
"Rahul janghu".isalpha()

#String formatting

name = input()
age = input()

print("Hey my name is",name,"And my age is",age)

name = input()
age = input()

print("Hey my name is {}, And my age is {}".format(name, age)) #{} are placeholder

name = input()
age = input()

print(f"Hey my name is {name}. And my age is {age}.")

#String concatenation

first = input()
second = input()

print(first ," ", + second)

"2" + 2

#Print all vowels of a given string

text = "The quick brown fox jumps over the lazy dog"

for i in text:
  if i == "a" or i == "e" or i == "i" or i == "o" or i == "u":
    print(i,end=" ")

#Check pallindrome
#A string is said to be palindrome if the reverse of string is the same as string
#eg radar = radar, radix != xidar

s = "Rahul"
j = s[::-1]
p = s[::]


for i in s:
  if j == j:
    print("It is palindrome")
    break
  else:
    print("no")
    break

text = "Hello world Hello"
length = len(text)

for i in text:
  if i >= text:
    print("number cant repeat")

  else:
    print(i,end=" ")

  break

#Lists
#Ordered collection of data, mutable type of data structures, contains multiple type of data and are iterable.

l = list()
print(type(l))

l1 = [1,2,3]
print(type(l1))
print(len(l1))

#accessing
print(l1[0])
print(l1[-len(l1)])
print(l1[-1])
print(id(l1))

#changing value
l1[0] = 9
print(l1)
print(id(l1))

#Iterable

for i in l1:
  print(i)

#Slicing
l = [1,2,3,4,5,6]
len(l)

print(l[0:3])
print(l[::-1])
print(l[5:0:-1])

#List inbuilt methods
#count : Returns the count of an object

budget = [100,200,300,150,100]
print(budget.count(100))
print(budget.count(500))

#index : Returns the index of 1st occurance of an object

budget = [100,200,300,150,100]
print(budget.index(200))
print(budget.index(100))

#pop : Removes and returns the last element of a list
budget.pop()

#remove : Removes the given object from our list

budget.remove(200)

budget

#sort : It sorts our list
budget.sort()
budget

#insert : Helps to add an element at a given index

budget.insert(0,20)
budget

#append
budget.append("Rahul")

budget

l1 = [1,2,3]
l2 = [4,5,6]
l1.append(l2)

l1

#extend
l1.extend(l2)

l1

#Heterogenous lists
l = [2,"Rahul",1.3,True]
type(l)

type(l[3])

for i in l:
  print(type(l[0:3:1]))

#2-D lists
l = [[1,2,3],[4,5,6],[7,8,9]]
l

l[0]

l[1]

l[2]

l[0][1]

#Iteration in 2D string

l = [[1,2,3],[4,5,6],[7,8,9]]

for i in l:
  for j in i:
    print(j)

#List Comprehension

l = []

for i in range(10):
  l.append(i)
print(l)

l = [(i ** 2) for i in range(20)]
l

#Challenge

l = [4,6,5,8,9,3,2,4,5,4,3,2,3,4]

population = ['0']
population += ['1','2']
print(population)

#Tuples
#ordered collection of data, unchangeable, iterable, heterogenous

t = ("Pluto","Mercury")
type(t)

t[0]

t[-1]

t[:]

t[0] = "Sun"

t = ("Rahul", 2, 24.4, True)
type(t)

t3 = (2)
type(t3)

t1 = ()
type(t1)

t = tuple("Rahul")
t

t = ([1,2],[4,5])
print(len(t))
print(type(t),t)

#Mutability
t = (4,5,6)
t[0]=45

t = ([1,2,3],"Rahul")
print(type(t), type(t[0]), type(t[1]))

#Unpacking a tuple
a = 3
b = 2
c = 5
d = 7
print(a,b,c,d)

a,b = 2,4
print(a,b)

t = (1,2,3,4)
a,b,c,d = t
print(a,b,c,d)

# tuple containing vowels
vowels = ('a', 'e', 'i', 'o', 'u')

# index of 'e' in vowels
for i in vowels:
    if i == vowels:
        i = vowels.index('z')
        break
    else:
        print(-1)
        break
    print(i)

name_lst = ["Vijay", "Vickey"]
tup = ("Item_1", 0.5, name_lst)
name_lst.append("Vishal")
print(tup)

elements = (10, 20, 30, 40, 50, 60, 70, 80)
print(elements[2:5], elements[:4], elements[3:100])

#Dictionary
#has key value pair form of data, ordered, not support indexing, accessed using key

d = {}
print(type(d))

#Creating non empty dictionary

fruits = {
    "Apple" : 120,
    "mango" : 100,
    "pineapple" : 90
}

type(fruits)

fruits

#zip = binds variables/ converts 2 variables into dictionary binding them into key:value format

name = ["Apple","Mango","Oranges"]
prices = [120,100,130]

fruit = dict(zip(name,prices))
print(fruit)

#Accessing values using key

fruit["Apple"]

#Accessing values using get method : to avoid error

fruits.get("Apple")

fruits.get("Guava","Not available") #passes default message if the key is not present

#Updating a Dictionary can be done by using key and update

#Updating the existing value

fruits["pineapple"] = {"small" : 90, "large" : 120}
fruits

#Updating with new value

fruits["Guava"] = 80
fruits

#update : updating multiple values

new = {"Grapes" : 120, "oranges" : 70, "berry" : 140}
fruits.update(new)
fruits

#Deleting data using pop, popitem and del

#Citizenship check

"Apple" in fruits

#dic.pop(key)

fruits.pop("Apple")
fruits

#dict.popitem() - removes last item from the dictionary

fruits.popitem()
fruits

#del object

del fruits
fruits

#Iterating in a dictionary

for i in fruit:
  print(i)

fruit["Apple"]

#Iterating both key and value

for i in fruit:
  print(i,fruit[i])

#Iterating using dict.items()

for key, value in fruit.items():
  print(key,value)

fruit.items()

#Dictionary methods

#keys() - fetches keys

fruit.keys()

#values() - fetches values

fruit.values()

#items() - fetches both keys and values

fruit.items()

#Challenge - take an input and find the freq of each letter and return the letter and their freq

name = "Rahul janghu"

freq = {}
for i in name:
  #check for presence
  if i not in freq:
    freq[i] = 1
  #if present increment the freq by factor of 1
  else:
    freq[i] += 1
print(freq)

#Sets : Unique collection, Unordered, Unindexed, Mutable

lst = [1,2,3,1,1]
lst

#Creating a Set : set() set(iterable)

#empty set

s = {}
type(s)

s = set()
print(s)
type(s)

#Non empty set

s = {1,2,3,1,2,4,5,1,2}
print(s)

s = set("rahul")
type(s)

s

#Iteration
for i in s:
  print(i)

#Updating a set
#add : For single element, update(iterable)

s = {1,2,3,3,5,4,6}
s

s.add(8)
s

name = "Rahul"
s.update(name)

s

#Deleting an element
#pop : removes random element. We are not sure what it is, remove(element): removes Particular element

s.pop()

s.remove(2)
s

#Intersection
#Suppose Scaler has two courses available for students. Python and Java.
#You want to find out which students are enrolled in both the Python and Java Courses. Then you csn use the intersection method.

#We are taking names instead of unique Ids for ease of understanding

python = {"Iron man","Hulk","Spidy","Rahul"}
Java = {"Iron man","Harry potter","Ant man"}

python.intersection(Java)

Java.intersection(python)

#Union
#Suppose you want to find out which students are enrolled in either the python or the java course or in both. Then you csn use the union method.

python = {"Iron man","Hulk","Spidy","Rahul"}
Java = {"Iron man","Harry potter","Ant man"}

python.union(Java)

#Difference : Suppose you want to find out the set of students who have enrolled in the Python course but not in Java course of vice-versa, then we can use the difference method.

python = {"Iron man","Hulk","Spidy","Rahul"}
Java = {"Iron man","Harry potter","Ant man"}

python.difference(Java)

#Challenge : Count number of unique elements in a sentence

sent = "be the change you wish to see in the world"
s = set(sent)
s

lst = sent.split()
lst

s = set(lst)

len(s)

#Final code

sent = "be the change you wish to see in the world"
#unique word list
lst = sent.split()

#Convert into set
s = set(lst)
print(len(s))

a={'Aurn', 'Nikhil', 'Seeta'}
a[0]= 'Arun'

#Functions : user defined piece of code. It works only when its called by user. It helps in reusability of code and helps in reducing errors in your code. example - print, range etc.
#Helps in reusability of code, Make code manageable and organised
#User defined and built-in

#Defining a function
def greet():
  #this is body of the function
  print("hey have a good day!!")

print(greet)
#Calling a function
greet()

#Docstring
def greet():
  """
  This function greets everyone when its called
  """
  print("hey,have a good day")

greet()
greet?

#Parameters
#These are place holders in the function.
#When defining them we call them as Parameters.
#When passing the actual value we call them as Arguements.

name = input()

def greet(name):
  print("hey, how are you",name)

greet(name)

def add(a,b):
  c = a + b
  print(c)

add(2,5)

#Return
#A function ends when return statement is executed
#It returns the expression back to the function
#The code after return statement are not executed
#If there is nor return value then function returns None

#Return vs print

def add(a,b):
  c = a+ b
  print(c)

add(3,4)

a = add(2,4)
type(a)

def add(a,b):
  c = a + b
  return c

add(2,4)

b = add(2,3)
print(b, type(b))

#If no return object then it returns Nonetype
def func():
  return

c = func()
print(c, type(c))

#Code after return statement does'nt get executed
def func():
  print("Before return")
  return "Rahul"
  print("After return")

func()

a = func()
#print(a)

a = func()
print(a)

a

#Returning multiple values
def intro(name, age, hobby):
  return name,age,hobby

c,d,e = intro("rahul",25,"Travelling")
print(c,d,e,sep=",")

c = intro("rahul",25,"Travelling")
print(c, type(c))

a , b = 2 , 3
print(a,b)

#Scope of variable
#There are two scope of a variable : Global and Local
#Global variable can be used anywhere in a program
#Local variable can only be used locally inside a program(function)

#if a can be used anywhere in the program
a = 5

def func():
  print(a)

func()
print(a)

a = 5

def func():
  x = 3
  print(x)

func()
print(a)
#print(x)

a = 5

def func():
  a = 20
  print(a)

func()
print(a)

#A global keyword is a keyword that allows a user to modify a variable outside the current scope.
#It is used to create global variables in Python from a non-global scope, i.e. inside a function.
#Global keyword is used inside a function only when we want to do assignments or when we want to change a variable. Global is not needed for printing and accessing.

a = 5

def func():
  global a
  a = 20
  print(a)

print(a)
func()
print(a)

#Lambda function : used when we need nameless function for short period of time

def add(a,b):
  return a + b

add(3,4)

(lambda a, b : a + b)(3,4)

func = lambda a, b : a + b
type(func)

func(5,2)

def larger(a, b):
  if a > b:
    return a;
  else:
    return b

larger(4,3)

(lambda a, b : a if a > b else b)(4,3)

large = lambda a, b : a if a > b else b

large(54,2)

lst = [(12,45),(2,3),(3,2)]
lst.sort()
lst

def k(x):
  return x[1]

lst.sort(key = k)

lst

lst.sort(key = lambda x : x[1])
lst

#Challenge : Write a Python function to print the even numbers from a given list.
#input - [1,2,4,3,5,6]
#output - 2 4 6

def even(li):
  #Iterate on the list li
  for i in li:
    #Check for even elements
    if i % 2 == 0:
      print(i, end=" ")

lst = [1,2,4,3,5,6]
even(lst)

#Challenge : Write a Python function that takes a list and returns a new list with unique elements of the first list
#input - [1,2,3,1,2,4]
#output - [1,2,3,4]

lst = [1,2,3,1,2,4]

def unique(li):
  new = []
  #Iterate on the li list
  for i in li:
    #We are adding only unique elements in new list
    if i not in new:
      new.append(i)

  #return new list
  return new

unique(lst)

12 not in lst

#Arguments vs Parameters
#Parameters : The values we pass while defining a function
#Arguments : The actual value of we pass when calling a function

#This name variable is known as parameter

def func(name):
  print("Hey my name is",name)

#Calling the function
#The actual value is known as agument

func("Rahul")

#Positional Arguments
#The value you pass when calling a function are matched according to their positions

def intro(name, hobby):
  print("Hey my name is",name)
  print("And my hobby is",hobby)

intro("Rahul","Cycling")

#Default arguments
#Giving default values to the parameters
#For these parameters passing value in arguments is optional

def intro(name, hobby = "Reading"):
  print("Hey my name is",name)
  print("And my hobby is",hobby)

intro("Rahul")

#Positioning of default and non-default arguments

def intro(name = "Rahul",hobby):
  print("Hey my name is",name)
  print("And my hobby is",hobby)

#Arbitrary Arguments
#When number of values you want to pass is not known
#Like we pass multiple values in print function
#The values are being stored in tuple

def test(*args):
  #print(args)
  print(type(args))

  #Iterate and print
  for i in args:
    print(i*i,end=" ")

test(1,2,3,4)

#Keyword arguments
#Variable number of kew word arguments
#It stores the data in dictionary format

def intro(**kwargs):
  #print(kwargs)
  print(type(kwargs))

  for key, values in kwargs.items():
    print(key,values, sep=" : ")

intro(name = "Rahul", age = 25, hobbies = ["Swimming","Read","Cycling"])

def mix(a ,b ,c, age = 25, *args, **kwargs):
  print(a,b,c)
  print(age)
  print(args)
  print(kwargs)

mix(2, 4, 5, 45, 6, 8, 9, name="rahul", hobby="swimming")

def intro(**kwargs, *args):
  print(agrs)
  print(kwargs)

def intro(*args,**kwargs):
  print(agrs)
  print(kwargs)

def convert(t):
    return t*9/5 + 32

print(convert(20))

#OOPs(Object Oriented Programming)
#The principles of OOPs are based on 4 pillars apart from Class and Objects
#A class hass attributes and behaivour

#Abstraction - displaying only essential information and hiding the details. eg - car will accletate but internal working of enginge not exposed

#Encapsulation - Bundling of data into a single unit. Bundling of all methods that can act on an object of the data, Car can have colors, brake, engine adn a lot of other methods

#Inheritance - When a class derives from another class. Any new car company can inherit all the information from car class

#Polymorphism - mean having many forms. Same class method can work differently for different objects.

#Creating Classes - blueprint to create objects, class keyword is used to create classes. By general conversation we start name wwith capital letter
#eg - int, float, string etc

class Car:
  pass

#Objects - instances or entities of a class. Has all the properties of its class
#eg - 1,2 are objects of int class

honda = Car()
type(honda)

type(1)

#Constructor : used to create and initialize an object of a class. Defined in the class. Executed automatically at the time of object creation.


class Human:
  #I want some properties to be with every Human objects
  #Dunder __

  def __init__(self, name, age, hobby):
    self.name = name
    self.age = age
    self.hobby = hobby

rahul = Human("Rahul",25,"Swimming")
emma = Human("Emma",34,"Reading")

print(rahul) #Memory allocation

rahul.name
rahul.hobby

emma.name

#Methods - apart from special methods you can make your custom methods. eg - Humans can speak, greet etc.

class Human:
  #Constructor
  def __init__(self,name,age,hobby):
    #These are known as attributes of an object
    self.name = name
    self.age = age
    self.hobby = hobby

  def greet(self):
    print(f"Hey my name is {self.name}. Good morning")

rahul = Human("rahul",25,"swimming")
rahul.greet()

#Class Variables
#These are common to the class
#eg - population of Human class is common to all objects

class Human:
  #Class variables
  population = 0
  data = []

  #Constructor
  def __init__(self,name,age):
    #These are known as attributes of an object
    self.name = name
    self.age = age

    #Increment population for every new Human object
    Human.population += 1
    Human.data.append(self.name)

  #Methods

  def greet(self):
    print(f"Hey my name is {self.name}. Good morning")

rahul = Human("Rahul", 35)

rahul.name

Human.population

rahul.population

emma = Human("Emma",32)
emma.population

Human.population

#More methods

class Human:
  #Class variables
  population = 0
  data = []

  #Constructor
  def __init__(self, name, age, alive = True):

    #These are known as attributes of an object
    self.name = name
    self.age = age
    self.alive = alive

    #Increment population for every new Human object
    Human.population += 1
    Human.data.append(self.name)

  #Methods

  def greet(self):
    print(f"Hey my name is {self.name}. Good morning")

  def dead(self):
    if self.alive:
      print(self.name,"is no more now.")
      Human.population -= 1
      self.alive = False
    else:
      print("This person is already dead")

  def child(self, number):
      Human.population += number

h1 = Human("H1",70)
h2 = Human("H2",60)

Human.population

h1.dead()

h1.dead()

h3 = Human("Adam",25)

Human.population

h3.child(2)

Human.population

#Inheritance - When a class derives attributes and methods from other class
#It gets access to all its methods and attributes
#This helps in resuability of code

#Human is base class
#Employee is Derived class

class Employee(Human):


    #Re-initiate constructor
  def __init__(self,name, age, company,post):
    super().__init__(name,age, company, post)

    #Attributes for employee class
    self.company = company
    self.post = post

    #Add some attributes
  def hire(self, person):
    print(f"{person} has been hired in our company")
    Human.data.append(person)
    Human.population += 1

e1 = Employee("Mark",34)

Human.population

e1.greet()

rahul = Human("Rahul", 35)

Human.population

rohit = Employee("Rohit",26,"Google","CEO")

rohit.post

Human.data

rohit.hire("Harry")

Human.data

rohit.dead()

Human.data

Human.population

#Polymorphism : having many forms, same class method can work defferently for different objects
#Operators level for polymorphism

a = 2
b = 4
#Adding
a + b

#Concating
"2" + "2"

#Function level polymorphism
# len, sum, custom

l = [1,2,3,4]
len(l)

len("rahul")

#sum
sum(l)

def mul(*args):
  total = 1
  for i in args:
    total *= i

  return total

mul(2,3,4)

class Human:

  def speak(self, language):
    print("I speak ", language)

#File handling
#A file is a container in a computer system for storing data
#Data is permanently stored in form of text/binary

#Opening a file
#open : returns a file handle
#In order to perform any kind of operation on file first we open

f = open("name.txt")

type(f) #_io.TextIOWrapper

f.closed #False / True

f.read() #'Hello i am Rahul'

f.close()

#Modes of opening a file
#'r' : read only
#'w' : write only
#'a' : appending data at the end of file
#'wt' : write text
#'wb' : write binary
#'rb' : read binary
#'rt' : read text

f = open("name.txt","w")
f.write("I am writable now") #18

f.close()

#With open
#Most common way to perform operation on files
#It closes the file after performing operations

with open("name.txt") as f:
  print(f.read())

#I am writable now

f.closed #True

with open("name.txt","w") as f:
  f.write("hey i am writable")

#Writing in a file
#You can write both text and binary file
#You can either write or append in a file

#We are creating new file here

with open("new.txt","w") as f:
  f.write("Hey new file created")

#Write in existing file

with open("new.txt","w") as f:
  f.write("This is the updated content of our file \n")
  f.write("This is new line")

#Read
#using read() method we can read a file
#It opens in read only format

with open("new.txt","r") as f:
  data = f.read()
  print(data)

#This is the updated content of our file
#This is new line

#read() : reads the whole data
#read(l) : reads data of length l
#tell() : tells you about the position of file handle
#speak() : it helps to re position your file handle
#readline() : reads data line by line

with open("new.txt","r") as f:

  #Reading first 4 chr
  data = f.read(4)
  print(data)

  print(f.tell())

  #Next 10 chr
  data = f.read(10)
  print(data)

  #tell : tell you the position of your file handle
  print(f.tell())

  #using seek you can reset your file handler

  f.seek(2)
  print(f.tell())

  print(f.read())

#This
#4
# is the up
#14
#2
#is the updated content of our file
#This is new line

with open("new,txt","r") as f:
  data = f.readlines()
  for i in data:
    print(data)

#This is the updated content of our file
#This is new line

#Binary data
#To read binary data we open file in "rt" mode
#To write binary data we open file in "wt" mode

with open("rahul.jpeg","rb") as f:
  data = f.read()
  print(data)

with open("rahul.jpeg","rb") as f:
  data = f.read()

  with open("new.jpeg","wb") as d:
    d.write(data)

#Append
#this mode helps us to append in a file

with open("name.txt","a") as f:
  f.write("This is appended data")

#Errors and Exceptions in Python
#When we write a faulty code the execution of program may stop due to the errors
#There can be some places where exceptions can be caused
#Errors are caused by wrong syntax
#Exceptions are logic based wherein syntax is right but logic isn't. Ex: Zero division

#Examples of errors - Syntax, Name, Type, File not found, IndentationError, ZeroDivisionError

print(dir(__builtins__))

#Try and Except
#try : This block handles the error in your code if any of it exists
#except : This block gives the output that you want to show if your code is faulty

a = 5
b = 0

#Put the suspect code in try block
try:
  print(a/b)
except Exception as e:
  print("there is an error that you might want to look for",e)

print("Hello rahul")

#Finally
#This block will be executed in any case
#It is helpful when you want to de-allocate resources
#Like closing a file, or db connection

a = 5
b = 0

try:
  print("open file")
  print(a/b)
except Exception as e:
  print("Error",e)
finally:
  print("close file")